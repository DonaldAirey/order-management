namespace Teraque.AssetNetwork
{

	using System;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Windows;
	using System.Windows.Threading;
	using Teraque;
	using Teraque.AssetNetwork.Properties;
	using Teraque.AssetNetwork.WebService;

	/// <summary>
	/// An application to explore and manage assets.
	/// </summary>
	partial class App : Application
	{

		/// <summary>
		/// Provides friendly names for the licensed products.
		/// </summary>
		static Dictionary<Guid, String> productNames = new Dictionary<Guid, String>()
		{
			{Teraque.Windows.Properties.Settings.Default.ExplorerChromeSuite, "Explorer Chrome Suite"}
		};

		/// <summary>
		/// Handle all unhandled exceptions.
		/// </summary>
		/// <param name="sender">The Object that generated the event.</param>
		/// <param name="dispatcherUnhandledExceptionEventArgs">Information about the exception event.</param>
		void OnDispatcherUnhandledException(Object sender, DispatcherUnhandledExceptionEventArgs dispatcherUnhandledExceptionEventArgs)
		{

			// A certain class of errors should kill the application, others will just mortally wound it.  This is used to euthanize the application when the right
			// conditions arise.
			Boolean isFatal = false;

			// This string will collect the error message that is eventually displayed to the user after the exceptions are examined in order of importance to the
			// user.  The more generic exceptions are examined first and then, if more specific information is available, it will overwrite the generic message.
			String errorMessage = null;

			// This handler will try to extract the most specific error message and work its way up to the least specific.  As a general rule, if a specific error
			// message can be made more friendly for the user, the effort is made to provide a less technical description and a more action-oriented message.
			if (dispatcherUnhandledExceptionEventArgs.Exception.InnerException != null)
			{

				// The inner exception has the real reason for this exception.
				Exception innerException = dispatcherUnhandledExceptionEventArgs.Exception.InnerException;

				// If a message wasn't extracted for a specific purpose above then use the general message associated with the inner exception as the text that the
				// user will see.
				if (errorMessage == null)
					errorMessage = dispatcherUnhandledExceptionEventArgs.Exception.InnerException.Message;

			}

			// The handling of this event works from the most specific error message to the least specific.  If no error message has been extracted by this point
			// the message associated with the exception that generated this event is used as the most general message.
			if (errorMessage == null)
				errorMessage = dispatcherUnhandledExceptionEventArgs.Exception.Message;

			// Display the message associated with the exception to the user.
			MessageBox.Show(errorMessage, Explorer.Properties.Resources.Title, MessageBoxButton.OK, MessageBoxImage.Error);

			// If the error was fatal then shut down the application.
			if (isFatal)
				Application.Current.Shutdown();

			// The exceptions will not kill the program.
			dispatcherUnhandledExceptionEventArgs.Handled = true;

		}

		/// <summary>
		/// Raises the Exit event.
		/// </summary>
		/// <param name="e">An ExitEventArgs that contains the event data.</param>
		protected override void OnExit(ExitEventArgs e)
		{

			// Disable the data model updates when we exit.  Without this we will leave an orphaned thread that prevents the application from exiting properly.
			DataModel.IsReading = false;

			// Allow the base class to handle the rest of the application shutdown.
			base.OnExit(e);

		}

		/// <summary>
		/// Raises the Startup event.
		/// </summary>
		/// <param name="e">A StartupEventArgs that contains the event data.</param>
		protected override void OnStartup(StartupEventArgs e)
		{

			// This will catch all unhandled exceptions including the ones that can be generated by the main window having trouble initializing.  The original
			// version was placed in the MainWindow but failed to catch XAML errors when the frame couldn't be loaded, particularly due to licensing errors, 
			// because the event handlers are not installed when the main window calls its constructors.
#if !DEBUG
			this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(this.OnDispatcherUnhandledException);
#endif

			// This handler will deal with the special case where the tenant has been unloaded.  Nearly all other communication errors will be retried periodically 
			// until the communication recovers, but this event occurs when the server has been intensionally shut down.  We'll terminate the application to give
			// the server a chance to recover.
			DataModel.TenantNotLoaded += this.OnTenantNotLoaded;

			// This starts the thread that reconciles the client data model with the server data model.
			DataModel.IsReading = true;

			// The base class will handle the rest of the startup event.
			base.OnStartup(e);

		}

		/// <summary>
		/// Handles the tenant being unloaded.
		/// </summary>
		/// <param name="sender">The object that invoked this event.</param>
		/// <param name="tenantName">The name of the tenant that couldn't be accessed on the server.</param>
		void OnTenantNotLoaded(Object sender, String tenantName)
		{

			// If the tenant has been unloaded then it is probably for a very good reason, such as a catestrophic database error.  In this scenario we're going to 
			// give the user a message to come back later before exiting.  It is best the server doesn't have dozens of zombie workstations polling it for data
			// while it is trying to reboot.
			this.Dispatcher.Invoke(new Action(() =>
			{
				MessageBox.Show(
					String.Format(Explorer.Properties.Resources.TenantNotLoaded, tenantName),
					Explorer.Properties.Resources.Title,
					MessageBoxButton.OK,
					MessageBoxImage.Error);
				this.Shutdown();
			}));

		}

	}

}
